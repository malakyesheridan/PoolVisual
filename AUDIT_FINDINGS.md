# Comprehensive Audit Findings: Enhancement Job Mask Query Issue

## Executive Summary

The outbox processor is finding 0 masks while the diagnostic endpoint finds 1 mask for the same `photoId`, using the same query method (`storage.getMasksByPhoto()`). This investigation reveals the root cause and all contributing factors.

## Root Cause Analysis

### Primary Issue: Row Level Security (RLS) Policies

**Finding:** The `masks` table has RLS enabled with a policy that checks `auth.uid()`:

```sql
CREATE POLICY "masks_select_policy" ON masks FOR SELECT
    USING (photo_id IN (
        SELECT p.id FROM photos p
        JOIN jobs j ON p.job_id = j.id
        WHERE j.org_id = ANY(get_user_org_ids(auth.uid()))
    ));
```

**Problem:**
- `auth.uid()` is a PostgreSQL function that returns the authenticated user's UUID
- This is typically used with Supabase Auth or similar systems
- The application uses **session-based authentication** (iron-session), not PostgreSQL auth
- When queries run without a PostgreSQL session context, `auth.uid()` returns `NULL`
- When `auth.uid()` is `NULL`, `get_user_org_ids(NULL)` returns an empty array `[]`
- The RLS policy filters out ALL masks because no orgs match

**Why Diagnostic Endpoint Works:**
- Called via HTTP request with `authenticateSession` middleware
- Has a valid session context
- **However**, this shouldn't matter for RLS unless...
- **OR** the connection is made as a superuser/table owner that bypasses RLS

**Why Outbox Processor Fails:**
- Runs in background context (fire-and-forget via `import().then()`)
- No HTTP request = no session context
- If RLS is enforced, `auth.uid()` is NULL → no masks visible

### Secondary Issues

1. **Transaction Timing**
   - Outbox processor is triggered immediately after transaction
   - The "transaction" function is not a real transaction (just sequential queries)
   - Each query auto-commits in Neon serverless
   - Potential race condition if mask was just saved

2. **Connection Context**
   - Outbox processor may run in different serverless function invocation
   - Different database connection instance
   - Potential connection pooling issues

3. **Drizzle ORM vs Raw SQL**
   - `storage.getMasksByPhoto()` uses Drizzle ORM
   - Outbox processor fallback uses raw SQL (`executeQuery`)
   - Both should behave the same regarding RLS, but there may be subtle differences

## Evidence

### 1. RLS Policy Structure
- File: `migrations/002_rls_policies.sql` lines 176-181
- Policy checks `auth.uid()` which requires PostgreSQL session-level auth
- Application uses application-level session auth (iron-session)

### 2. Query Methods
- **Diagnostic Endpoint** (`/api/debug/enhancement/:jobId`):
  - Uses `authenticateSession` middleware
  - Calls `storage.getMasksByPhoto(job[0].photo_id)`
  - Finds 1 mask ✅

- **Outbox Processor** (`processOutboxEvents()`):
  - No authentication middleware
  - Calls `storage.getMasksByPhoto(effectivePhotoId)`
  - Finds 0 masks ❌
  - Has fallback to direct SQL query (also finds 0 masks)

### 3. Database Connection
- Both use same underlying connection (`getSql()` / `getDatabase()`)
- Singleton pattern ensures same connection instance
- Connection likely uses superuser/owner role (from DATABASE_URL)
- **If connection is superuser, RLS should be bypassed**

## Critical Question

**If the connection is a superuser (which bypasses RLS), why does the outbox processor fail?**

Possible explanations:
1. **RLS is still enforced** - Connection is NOT superuser, or RLS bypass doesn't work as expected
2. **Timing issue** - Mask query happens before mask is committed (unlikely, mask was saved before enhance)
3. **Different execution context** - Outbox processor runs in different environment where RLS IS enforced
4. **Drizzle ORM issue** - Drizzle may be applying additional filters or using different connection

## Recommended Tests

1. **Verify connection role:**
   ```sql
   SELECT current_user, current_setting('role', true);
   ```

2. **Check RLS status:**
   ```sql
   SELECT tablename, rowsecurity FROM pg_tables WHERE tablename = 'masks';
   ```

3. **Test RLS policy evaluation:**
   ```sql
   SELECT auth.uid() as auth_uid;
   SELECT get_user_org_ids(auth.uid()) as org_ids;
   ```

4. **Compare query results:**
   - Run same query in diagnostic endpoint vs outbox processor
   - Log the actual SQL generated by Drizzle
   - Compare with raw SQL query

5. **Check execution context:**
   - Log connection details in both contexts
   - Verify if they use same connection instance
   - Check if RLS is actually being enforced

## Recommended Fix

**Option 1: Bypass RLS for System Queries (Recommended)**
- Create a PostgreSQL function with `SECURITY DEFINER` that queries masks
- This function runs with creator's privileges (bypasses RLS)
- Use this function in outbox processor

**Option 2: Set PostgreSQL Role**
- Before querying masks in outbox processor, set the role to a system user
- This requires configuring a system role in PostgreSQL

**Option 3: Use Service Account Connection**
- Create separate DATABASE_URL for system operations
- This connection uses a role that bypasses RLS

**Option 4: Disable RLS for System Operations**
- Temporarily disable RLS for the query
- Re-enable after query
- Requires superuser privileges

## Files Involved

1. `migrations/002_rls_policies.sql` - RLS policy definition
2. `server/jobs/outboxProcessor.ts` - Outbox processor (failing query)
3. `server/routes.ts` - Diagnostic endpoint (working query)
4. `server/storage.ts` - `getMasksByPhoto()` implementation
5. `server/db.ts` - Database connection setup

## Next Steps

1. Verify the actual database role being used
2. Test if RLS is actually being enforced
3. Implement one of the recommended fixes
4. Add logging to verify fix works

